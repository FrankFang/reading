# TDD (Testing-Driven Development)

TDD 是一个迭代的开发过程，每次迭代从编写一个测试开始。

# 开发顺序

## 传统的写代码方式

猜测解决问题需要什么样的代码，容易导致臃肿和紧耦合的解决方案。

如果这时没有单元测试，那么得到的方案可能包含永远不会执行的代码，更不用说测试这些代码了。

## TDD 的写代码方式

把定义要达到的目标作为开发的开端。**正确的 TDD 将确保一个系统中绝不存在没执行过的代码**。

# TDD 中的设计

* 不要『一开始就大设计』（Big Design Up Front）
* 不要『一开始就没设计』（No Design Up Front）
* TDD 注重的是
  0. 写出不耦合的代码
  0. 单一职责
  0. 避免不必要的膨胀
  
TDD 对开发过程紧密控制，能够让很多设计决策推迟到确实需要的时候再确定。因此能迎合不断变化的需求。

**必须要写描述清楚要解决的问题才能开始编程。**

# 迭代

每次迭代包含四步：

0. 编写一个 TC（测试用例，下同）
0. 运行测试用例，查看*新 TC 的失败*
0. 让这个 TC 运行成功
0. 重构以消除冗余

每次迭代一般只有几分钟。如果你认为代码中有需要改动的地方，那么应该把它放到下次迭代中，先完成**本次迭代**。（不然又变成原先的编程方式了）

所以你需要一个 Todo 列表，能方便地将新内容放进去。

## 第一步：编写一个 TC

### 经验

0. 添加尽可能少的代码，并且使次 TC 失败。
0. 新的 TC 不应当重复那些已经成功的断言。
0. 一个 TC 不应该包含任何分支逻辑。
0. 如果功能代码什么都没写，TC 都能运行成功，那么这个 TC 可以删掉。（可以把这种情况变成一种对环境的要求声明）

### 输入与输出

输入不仅是函数的参数，也包括测试功能所以来的任何东西：全局对象、特定对象的特定状态等。输出也是相同的道理。

例如测试 `string.trim` 是，可以断言 `typoef ''.trim === 'function'`，以防有人将 `''.trim` 覆盖了。

## 第二步：观看 TC 失败

**毕竟，我们写 TC 就是为了让它失败，不是吗？**

这么做是为了让我们确认我们对代码当前状态的认知：TC 失败的时候是怎样的。

## 第三步：使 TC 成功

**提供最简单的能用方案**即可。

You ain't gonna need it，如果没必要，我们绝不添加功能。一个典型的反面例子就是方法参数国语灵活。不能因为一个函数可以接受任意多个任意类型的参数，就让函数接受可能参数的组合！除非 TC 里面需要这些组合。

你没必要让 TC 一次运行就能成功，鼓励小步前进。

最简单的能用方案不代表你可以 hard code（把值写死），如果你的目标是高效的代码，那么应寻找通用方案。不过 TDD 认为 hard code 没什么不好，这是为了进度所采用的折衷办法。

## 第四步：重构以消除冗余

**测试通过后，应该回顾一下我们到目前为止的工作**，做出必要的调整来消除冗余，改善设计。


此阶段的一个原则：测试应当保持通过。

如果重构的代码不能被 TC 覆盖，那么就推迟该重构，直到 TC 满足了要求。

# 提高代码覆盖率

通过一次次迭代来提高代码覆盖率。功能需求满足后，就应该把注意力放在边缘条件、更多输入类型等功能上。

# 让 TDD 简单易行

自动测试：在每一次文件被保存时测试自动运行。用颜色表示成功（绿色）和失败（红色）。











